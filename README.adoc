# Debux
:source-language: clojure
:source-highlighter: coderay
:sectnums:
:imagesdir: ./doc/img
:toc:

*Debux* is a simple but useful library for debugging Clojure and ClojureScript. I wrote
this library to debug my own Clojure(Script) code and to analyze other developer's
one.

* Refer to https://github.com/philoskim/debux/tree/master/doc/v0.2.1/README.adoc[here] for
  the earlier version of documentation.

## Prerequisites

* clojure 1.8.0 or later
* clojurescript 1.9.562 or later


## Installation

To include *debux* in your project, simply add the following to your *project.clj* dependencies:


[source]
....
[philoskim/debux "0.3.1"]
....



## How to use
 
In Clojure, the following line should be included in your file to use *debux* library.


[source]
....
(use 'debux.core)
....

In ClojureScript, the following `(:require pass:q[...])` line has to be included in your
file to use *debux* library.


[source]
.example.core.cljs
....
(ns example.core
  (:require [debux.cs.core :as d :refer-macros [clog clogn dbg dbgn break]]))
....

  
## New feature added in version 0.3.1

The two new macros `dbgn` which is for Clojure/CloujureScript REPL and `clogn` which is
for ClojureScript browser console only are added to *debux* library. Appended `n` to these
two macro names means *Nested forms*. Now you can debug every nested form without
affecting program executions. This feature is very useful, especially when you analyze
other developer's source code.

Now you can see the evaluated output of outer-most form by using `dbg` or `clog` and the
evaluated outputs of every nested form by using `dbgn` or `clogn`.

NOTE: You can see every example source code of this document in
https://github.com/philoskim/debux/tree/master/example[example] folder.


### Simple example

[source]
....
(dbgn (defn foo [a b & [c]]
        (if c
          (* a b c)
          (* a b 100))))

(foo 2 3)
; => 600

(foo 2 3 10)
; => 60
....

[listing]
.REPL output
----
dbgn: (defn foo [a b & [c]] (if c (* a b c) (* a b 100))) =>

| c =>
|   nil
| a =>
|   2
| b =>
|   3
| (* a b 100) =>
|   600
| (if c (* a b c) (* a b 100)) =>
|   600

| c =>
|   10
| a =>
|   2
| b =>
|   3
| c =>
|   10
| (* a b c) =>
|   60
| (if c (* a b c) (* a b 100)) =>
|   60
----


### Detailed examples

* `dbgn/clogn` don't have any problem in handling all functions.

* `dbgn/clogn`, however, can have some problems in case of macros and special forms.

** Some macros like `when` don't have any problem when used in `dbgn/clogn`.

** Other macros with binding vector like `defn` can have some problem because they have
   bindnig symbols which must not be evaluated. In case of special forms and those macros
   in `clojure.core` namespace, `degn/clogn` macro can handle them appropriately.
+
NOTE: However, `dbgn/clogn` cannot handle `recur` special form because of the
      implementation restricion. *Be careful* not to use `dbgn/clogn` in case of the form
      which includes `recur` special form.

** In some case, Clojure developers can write their own macros which `dbgn/clogn` cannot
   handle appopriately. So I categorized those macros in `clojure.core` namespace as
   following table and you can register your own macros according to the macro types in
   the table. I will explain it in <<how-to-register>>.


[#macro-type-table, cols="^3m,<7m", options="header"]
.Categorized 15 types of macros in `dbgn/clogn`
|===

| Macro types | Macros in `clojure.core` and special forms
| :def-type   | def defonce
| :defn-type  | defn defn-
| :fn-type    | fn fn*
| :let-type   | let binding dotimes if-let if-some when when-first when-let
                when-some with-in-str with-local-vars with-open with-out-str
                with-redefs
| :letfn-type | letfn
| :for-type   | for doseq
| :case-type  | case
| :skip-arg-1-type     | set! with-precision
| :skip-arg-2-type     | pass:q[as->]
| :skip-arg-1-2-type   | 
| :skip-arg-1-3-type   | defmethod
| :skip-arg-2-3-type   | amap areduce
| :skip-form-itself-type  | catch comment declare definline definterface defmacro defmulti
                            defprotocol defrecord defstruct deftype extend-protocol
                            extend-type finally gen-class gen-interface import loop memfn new
                            ns proxy proxy-super quote refer-clojure reify sync var throw
| :expand-type | pass:q[.. -> ->> doto cond-> cond->> condp import some-> some->>]
| :dot-type    | .

|===


#### `:def-type` example

This type of macros have the fitst argument which must not be evaluated and can have
optional `doc-string` argument.

[source]
....
(dbgn (def my-function "my function doc-string"
        (fn [x] (* x x x))))

(my-function 10)
; => 1000
....


[listing]
.REPL output
----
dbgn: (def my-function (fn [x] (* x x x))) =>
| (fn [x] (* x x x)) =>
|   #function[example.core/eval24554/result--24229--auto----24555]
| (def my-function (fn [x] (* x x x))) =>
|   #'example.core/my-function

 x =>
   10
 x =>
   10
 x =>
   10
 (* x x x) =>
   1000
----


#### `:defn-type` example

This type of macros have the binding vector argument which must not be evaluated and can
have optional `doc-string`, `attr-map`, or `prepost-map` arguments.

[source]
....
(dbgn (defn add
        "add doc-string"
        [a b]
        (+ a b)))

(add 10 20)
; => 30
....

[listing]
.REPL output
----
dbgn: (defn add add doc-string [a b] (+ a b)) =>

| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30
----

{empty} +


You can debug multiple-arity functions as well.

[source]
....
(dbgn (defn my-add
        "add doc-string"
        ([] 0)
        ([a] a)
        ([a b] (+ a b))
        ([a b & more] (apply + a b more))))

; The function body in this case doesn't have any symbol
; to evaluate, so any output is not printed at all. 
(my-add)
; => 0

(my-add 10)
; => 10

(my-add 10 20)
; => 30 

(my-add 10 20 30 40)
; => 100
....

[listing]
.REPL output
----
dbgn: (defn my-add add doc-string ([] 0) ([a] a) ([a b] (+ a b)) ([a b & more] (apply + a b more))) =>

| a =>
|   10

| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30

| + =>
|   #function[clojure.core/+]
| a =>
|   10
| b =>
|   20
| more =>
|   (30 40)
| (apply + a b more) =>
|   100
----

{empty} +

You can have multiple ``dbgn/clogn``s.

[source]
....
(dbgn (defn calc1 [a1 a2] (+ a1 a2)))
(dbgn (defn calc2 [s1 s2] (- 100 (calc1 s1 22))))
(dbgn (defn calc3 [m1 m2] (* 10 (calc2 m1 m2))))

(calc3 2 5)
; => 760
....


[listing]
.REPL output
----
dbgn: (defn calc1 [a1 a2] (+ a1 a2)) =>

dbgn: (defn calc2 [s1 s2] (- 100 (calc1 s1 22))) =>

dbgn: (defn calc3 [m1 m2] (* 10 (calc2 m1 m2))) =>

|| m1 =>
||   2
|| m2 =>
||   5
||| s1 =>
|||   2
|||| a1 =>
||||   2
|||| a2 =>
||||   22
|||| (+ a1 a2) =>
||||   24
||| (calc1 s1 22) =>
|||   24
||| (- 100 (calc1 s1 22)) =>
|||   76
|| (calc2 m1 m2) =>
||   76
|| (* 10 (calc2 m1 m2)) =>
||   760
----


#### `:fn-type` example

This type of macros have the binding vector argument which must not be evaluated and can
have optional function name. So it is a little different from `:defn-type` macros.

[source]
....
(dbgn (reduce (fn [acc i] (+ acc i)) 0 [1 2 3 4 5]))
; => 15
....

[listing]
.REPL output
----
dbgn: (reduce (fn [acc i] (+ acc i)) 0 [1 2 3 4 5]) =>
| (fn [acc i] (+ acc i)) =>
|   #function[example.core/eval25034/result--24229--auto----25035]
| [1 2 3 4 5] =>
|   [1 2 3 4 5]
| acc =>
|   0
| i =>
|   1
| (+ acc i) =>
|   1
| acc =>
|   1
| i =>
|   2
| (+ acc i) =>
|   3
| acc =>
|   3
| i =>
|   3
| (+ acc i) =>
|   6
| acc =>
|   6
| i =>
|   4
| (+ acc i) =>
|   10
| acc =>
|   10
| i =>
|   5
| (+ acc i) =>
|   15
| (reduce (fn [acc i] (+ acc i)) 0 [1 2 3 4 5]) =>
|   15
----


{empty} +


[source]
....
(dbgn (map #(* % 10) [1 2 3 4 5]))
; => (10 20 30 40 50)
....

[listing]
.REPL output
----
dbgn: (map (fn* [p1__25079#] (* p1__25079# 10)) [1 2 3 4 5]) =>
| (fn* [p1__25079#] (* p1__25079# 10)) =>
|   #function[example.core/eval25080/result--24229--auto----25081]
| [1 2 3 4 5] =>
|   [1 2 3 4 5]
| (map (fn* [p1__25079#] (* p1__25079# 10)) [1 2 3 4 5]) =>
|   | p1__25079# =>
|   |   1
|   | (* p1__25079# 10) =>
|   |   10
|   | p1__25079# =>
|   |   2
|   | (* p1__25079# 10) =>
|   |   20
|   | p1__25079# =>
|   |   3
|   | (* p1__25079# 10) =>
|   |   30
|   | p1__25079# =>
|   |   4
|   | (* p1__25079# 10) =>
|   |   40
|   | p1__25079# =>
|   |   5
|   | (* p1__25079# 10) =>
|   |   50
|   (10 20 30 40 50)
----
 


#### `:let-type` example

This type of macros have the binding vector argument which must not be evaluated.

[source]
....
(dbgn (let [a (+ 1 2)
            [b c] [(+ a 10) (* a 2)]] 
         (- (+ a b) c)))
; => 10
....


[listing]
.REPL output
----
dbgn: (let [a (+ 1 2) [b c] [(+ a 10) (* a 2)]] (- (+ a b) c)) =>
| (+ 1 2) =>
|   3
| a =>
|   3
| (+ a 10) =>
|   13
| a =>
|   3
| (* a 2) =>
|   6
| [(+ a 10) (* a 2)] =>
|   [13 6]
| a =>
|   3
| b =>
|   13
| (+ a b) =>
|   16
| c =>
|   6
| (- (+ a b) c) =>
|   10
| (let [a (+ 1 2) [b c] [(+ a 10) (* a 2)]] (- (+ a b) c)) =>
|   10
----


#### `:letfn-type` example

This type of macro has the special biding vector syntax which is a bit different from
`:fn-type`.

[source]
....
(dbgn (letfn [(twice [x]
                (* x 2))
              (six-times [y]
                (* (twice y) 3))]
        (six-times 15)))
; => 90
....


[listing]
.REPL output
----
dbgn: (letfn [(twice [x] (* x 2)) (six-times [y] (* (twice y) 3))] (six-times 15)) =>
| y =>
|   15
| x =>
|   15
| (* x 2) =>
|   30
| (twice y) =>
|   30
| (* (twice y) 3) =>
|   90
| (six-times 15) =>
|   90
| (letfn [(twice [x] (* x 2)) (six-times [y] (* (twice y) 3))] (six-times 15)) =>
|   90
----


#### `:for-type` example

This type of macros have a little different syntax from `:let-type` macros, because it
can have `:let`, `:when`, or `:while` clause.
 
[source]
....
(dbgn (for [x [0 1 2 3 4 5]
            :let [y (* x 3)]
            :when (even? y)]
        y))
; => (0 6 12)
....


[listing]
.REPL output
----
dbgn: (for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y) =>
| [0 1 2 3 4 5] =>
|   [0 1 2 3 4 5]
| (for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y) =>
|   | x =>
|   |   0
|   | (* x 3) =>
|   |   0
|   | y =>
|   |   0
|   | (even? y) =>
|   |   true
|   | y =>
|   |   0
|   | x =>
|   |   1
|   | (* x 3) =>
|   |   3
|   | y =>
|   |   3
|   | (even? y) =>
|   |   false
|   | x =>
|   |   2
|   | (* x 3) =>
|   |   6
|   | y =>
|   |   6
|   | (even? y) =>
|   |   true
|   | y =>
|   |   6
|   | x =>
|   |   3
|   | (* x 3) =>
|   |   9
|   | y =>
|   |   9
|   | (even? y) =>
|   |   false
|   | x =>
|   |   4
|   | (* x 3) =>
|   |   12
|   | y =>
|   |   12
|   | (even? y) =>
|   |   true
|   | y =>
|   |   12
|   | x =>
|   |   5
|   | (* x 3) =>
|   |   15
|   | y =>
|   |   15
|   | (even? y) =>
|   |   false
|   (0 6 12)
----


#### `:case-type` example

This type of macro has the special syntax. Refer to
https://clojuredocs.org/clojure.core/case[here] about details.

[source]
....
(dbgn (let [mystr "hello"]
        (case mystr
          "" 0
          "hello" (count mystr))))
; => 5
....


[listing]
.REPL output
----
dbgn: (let [mystr "hello"] (case mystr  0 hello (count mystr))) =>
| mystr =>
|   "hello"
| mystr =>
|   "hello"
| (count mystr) =>
|   5
| (case mystr "" 0 "hello" (count mystr)) =>
|   5
| (let [mystr "hello"] (case mystr "" 0 "hello" (count mystr))) =>
|   5
----

{empty} +


[source]
....
(dbgn (case 'a
        (x y z) "x, y, or z"
        "default"))
; => "default"
....

[listing]
.REPL output
----
dbgn: (case (quote a) (x y z) x, y, or z "default") =>
| (case (quote a) (x y z) "x, y, or z" "default") =>
|   "default"
----


#### `:skip-arg-1-type` example

This type of macros have the first argument which must not be evaluated. So `dbgn/clogn`
internally skips the evaluation of this argument.

[source]
....
(dbgn (with-precision 10 (/ 1M 6)))
; => 0.1666666667M
....


[listing]
.REPL output
----
dbgn: (with-precision 10 (/ 1M 6)) =>
| (/ 1M 6) =>
|   0.1666666667M
| (with-precision 10 (/ 1M 6)) =>
|   0.1666666667M
----

#### `:skip-arg-2-type` example

This type of macros have the second argument which must not be evaluated. So `dbgn/clogn`
internally skips the evaluation of this argument.

[source]
....
(dbgn (as-> 0 n
        (inc n)
        (inc n)))
; => 2
....


[listing]
.REPL output
----
dbgn: (as-> 0 n (inc n) (inc n)) =>
| n =>
|   0
| (inc n) =>
|   1
| n =>
|   1
| (inc n) =>
|   2
| (as-> 0 n (inc n) (inc n)) =>
|   2
----


#### `:skip-arg-1-2-type` example

This type of macros have the first and second arguments which must not be evaluated. So
`dbgn/clogn` internally skips the evaluation of those arguments. However, I can't find this
type of macros in `clojure.core` namespace but add this type for completeness and the
future possibilities of this type of macros.


#### `:skip-arg-1-3-type` example

This type of macros have the first and third arguments which must not be evaluated. So
`dbgn/clogn` internally skips the evaluation of those arguments.

[source]
....
(defmulti greeting
  (fn [x] (:language x)))

(dbgn (defmethod greeting :english [map]
        (str "English greeting: " (:greeting map))))

(dbgn (defmethod greeting :french [map]
        (str "French greeting: " (:greeting map))))

(def english-map {:language :english :greeting "Hello!"})
(def french-map {:language :french :greeting "Bonjour!"})

(greeting english-map)
(greeting french-map)
....


[listing]
.REPL output
----
 map =>
   {:language :english, :greeting "Hello!"}
 (:greeting map) =>
   "Hello!"
 (str "English greeting: " (:greeting map)) =>
   "English greeting: Hello!"

 map =>
   {:language :french, :greeting "Bonjour!"}
 (:greeting map) =>
   "Bonjour!"
 (str "French greeting: " (:greeting map)) =>
   "French greeting: Bonjour!"
----


#### `:skip-arg-2-3-type` example

This type of macros have the second and third arguments which must not be evaluated. So
`dbgn/clogn` internally skips the evaluation of those arguments.


[source]
....
(let [xs (float-array [1 2 3])]
  (dbgn (areduce xs i ret (float 0)
                 (+ ret (aget xs i)))))
; => 6.0
....


[listing]
.REPL output
----
dbgn: (areduce xs i ret (float 0) (+ ret (aget xs i))) =>
| xs =>
|   [1.0, 2.0, 3.0]
| (float 0) =>
|   0.0
| ret =>
|   0.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   0
| (aget xs i) =>
|   1.0
| (+ ret (aget xs i)) =>
|   1.0
| ret =>
|   1.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   1
| (aget xs i) =>
|   2.0
| (+ ret (aget xs i)) =>
|   3.0
| ret =>
|   3.0
| xs =>
|   [1.0, 2.0, 3.0]
| i =>
|   2
| (aget xs i) =>
|   3.0
| (+ ret (aget xs i)) =>
|   6.0
| (areduce xs i ret (float 0) (+ ret (aget xs i))) =>
|   6.0
----


#### `:skip-form-itself-type` example

This type of macros have too complex to parse, so `dbgn/clogn` skips form itself and does nothing.
  

#### `:expand-type` example

This type of macros will be exhaustively expanded and then the output will be printed.

[source]
....
(dbgn (-> "a b c d" 
          .toUpperCase 
          (.replace "A" "X") 
          (.split " ") 
          first))
; => "X"
....

[listing]
.REPL output
----
dbgn: (-> "a b c d" .toUpperCase (.replace "A" "X") (.split " ") first) =>  ;; <1>
| (.toUpperCase "a b c d") =>
|   "A B C D"
| (.replace (.toUpperCase "a b c d") "A" "X") =>
|   "X B C D"
| (.split (.replace (.toUpperCase "a b c d") "A" "X") " ") =>
|   ["X", "B", "C", "D"]
| (first (.split (.replace (.toUpperCase "a b c d") "A" "X") " ")) =>       ;; <2>
|   "X"
----

* You can compare the original form <1> and the exhaustively expanded form <2>.


{empty} +

[source]
....
(dbgn (.. "fooBAR"  toLowerCase  (contains "ooba")))
; => true
....


[listing]
.REPL output
----
dbgn: (.. "fooBAR" toLowerCase (contains "ooba")) =>   ;; <1>
| (. "fooBAR" toLowerCase) =>
|   "foobar"
| (. (. "fooBAR" toLowerCase) (contains "ooba")) =>    ;; <2>
|   true
----

* You can compare the original form <1> and the exhaustively expanded form <2>.

{empty} +

[source]
....
(let [x 1 y 2]
  (dbgn (cond-> []
          (odd? x) (conj "x is odd")
          (zero? (rem y 3)) (conj "y is divisible by 3")
          (even? y) (conj "y is even"))))
; => ["x is odd" "y is even"]
....

[listing]
.REPL output
----
dbgn: (cond-> []                        ;; <1>
        (odd? x) (conj "x is odd") 
        (zero? (rem y 3)) (conj "y is divisible by 3")
        (even? y) (conj "y is even")) =>
| [] =>
|   []
| x =>
|   1
| (odd? x) =>
|   true
| G__25146 =>
|   []
| (conj G__25146 "x is odd") =>
|   ["x is odd"]
| (if (odd? x) (conj G__25146 "x is odd") G__25146) =>
|   ["x is odd"]
| y =>
|   2
| (rem y 3) =>
|   2
| (zero? (rem y 3)) =>
|   false
| G__25146 =>
|   ["x is odd"]
| (if (zero? (rem y 3)) (conj G__25146 "y is divisible by 3") G__25146) =>
|   ["x is odd"]
| y =>
|   2
| (even? y) =>
|   true
| G__25146 =>
|   ["x is odd"]
| (conj G__25146 "y is even") =>
|   ["x is odd" "y is even"]
| (if (even? y) (conj G__25146 "y is even") G__25146) =>
|   ["x is odd" "y is even"]
| (clojure.core/let [G__25146 []        ;; <2>
|                    G__25146 (if (odd? x)
|                               (conj G__25146 "x is odd")
|                               G__25146)
|                    G__25146 (if (zero? (rem y 3))
|                               (conj G__25146 "y is divisible by 3")
|                               G__25146)]
|   (if (even? y)
|     (conj G__25146 "y is even") G__25146)) =>
|    ["x is odd" "y is even"]
----

* You can compare the original form <1> and the exhaustively expanded form <2>. I
  rearranged the output only in both <1> and <2> for convenience.


#### `:dot-type` example

[source]
....
(dbgn (. (java.util.Date.) getMonth))
; => 5
....


[listing]
.REPL output
----
dbgn: (. (java.util.Date.) getMonth) =>
| (java.util.Date.) =>
|   #inst "2017-06-27T08:04:46.480-00:00"
| (. (java.util.Date.) getMonth) =>
|   5
----

[#how-to-register]
### How to register your own macros in using `dbgn/clogn` macro

* If you have some error when analyzing some source code while using `dbgn/clogn` macro,
  first of all, you have to figure out what kind of macro (refer to <<macro-type-table>>)
  caused the error and then register the macro by using `register-macros!` and see the
  registerd macros by using `show-macros`.

* Unfortunately, it is impossible to register your own macros in ClojureScript, because
  you cannot change compile-time states in ClojureScript run-time environment. However, it
  may be possible in bootstrapped ClojureScript, so I prepared the same API but didn't
  test it yet.

[source]
.API
....
(register-macros! macro-type macros)

(show-macros)
(show-macros macro-type)
....


[source]
.example.core.clj
....
(ns example.core)

(use 'debux.core)

(defmacro my-let [bindings & body]
  `(let ~bindings ~@body))

(register-macros! :let-type `[my-let])
(dbg (show-macros :let-type))
(dbg (show-macros))

(dbgn (my-let [a 10 b (+ a 10)] (+ a b)))
....

NOTE: *backquote* (pass:q[`]) must be used in front of a vector of symbols, instead of
*quote* (pass:q[`]).


[listing]
.REPL output
----
dbg: (show-macros :let-type) =>
|   #{clojure.core/when-let clojure.core/let clojure.core/with-local-vars
|     clojure.core/if-let clojure.core/when-some example.core/my-let
|     clojure.core/dotimes clojure.core/with-open clojure.core/if-some
|     clojure.core/with-redefs clojure.core/binding clojure.core/when
|     clojure.core/with-in-str clojure.core/with-out-str
|     clojure.core/when-first}

dbg: (show-macros) =>
|   {:fn-type #{clojure.core/fn fn*},
|    :skip-form-itself-type
|    #{clojure.core/proxy-super clojure.core/defmacro
|      clojure.core/definterface clojure.core/sync clojure.core/defrecord
|      clojure.core/declare clojure.core/deftype clojure.core/comment
|      finally clojure.core/gen-class clojure.core/refer-clojure
|      clojure.core/memfn clojure.core/extend-type new
|      clojure.core/definline clojure.core/defstruct clojure.core/defmulti
|      clojure.core/ns clojure.core/proxy clojure.core/extend-protocol var
|      quote clojure.core/reify catch clojure.core/gen-interface
|      clojure.core/loop clojure.core/import clojure.core/defprotocol
|      throw},
|    :case-type #{clojure.core/case},
|    :skip-arg-2-3-type #{clojure.core/areduce clojure.core/amap},
|    :skip-arg-1-type #{clojure.core/with-precision set!},
|    :let-type
|    #{clojure.core/when-let clojure.core/let clojure.core/with-local-vars
|      clojure.core/if-let clojure.core/when-some example.core/my-let
|      clojure.core/dotimes clojure.core/with-open clojure.core/if-some
|      clojure.core/with-redefs clojure.core/binding clojure.core/when
|      clojure.core/with-in-str clojure.core/with-out-str
|      clojure.core/when-first},
|    :skip-arg-2-type #{clojure.core/as->},
|    :defn-type #{clojure.core/defn clojure.core/defn-},
|    :for-type #{clojure.core/for clojure.core/doseq},
|    :def-type #{clojure.core/defonce def},
|    :letfn-type #{clojure.core/letfn},
|    :dot-type #{.},
|    :skip-arg-1-2-type #{},
|    :expand-type
|    #{clojure.core/doto clojure.core/->> clojure.core/some->>
|      clojure.core/.. clojure.core/-> clojure.core/some->
|      clojure.core/cond-> clojure.core/condp clojure.core/import
|      clojure.core/cond->>},
|    :skip-arg-1-3-type #{clojure.core/defmethod}}

dbgn: (my-let [a 10 b (+ a 10)] (+ a b)) =>
| a =>
|   10
| (+ a 10) =>
|   20
| a =>
|   10
| b =>
|   20
| (+ a b) =>
|   30
| (my-let [a 10 b (+ a 10)] (+ a b)) =>
|   30
----



## Various options

* `dbg/dbgn` can be used in Clojure REPL.

* `dbg/dbgn`, `clog/clogn` and `break` can be used in ClojureScript browser REPL like
  link:https://github.com/tomjakubowski/weasel[weasel] or
  https://github.com/bhauman/lein-figwheel[figwheel].
+
TIP: However, I recommend that you should use `clog` instead of `dbg`, because `clog` macro
uses the `console.log` fuction of browser's developer tools to style the form.


* `clog/clogn` and `break` can be used in the ClojureScript browser console like Google
  DevTool.


* The various options can be added and combinated in any order after the form.

[cols="^1m,^1m,^1m,^1m,^1m,^1m", options="header"]
.*debux* macro options
|===

| Options | dbg | dbgn | clog | clogn | break

| string  | O   |   O   |  O   |  O   |   O
| number  | O   |   O   |  O   |  O   |   X 
| :if     | O   |   O   |  O   |  O   |   O
| :style  | X   |   X   |  O   |  O   |   X
| :once   | X   |   X   |  O   |  X   |   X
| :js     | X   |   X   |  O   |  X   |   X

|===

* Legend: `O` (supported), `X` (not supported)

### String option

You can add your own message in a string and it will be printed betwen less-than and more-than sign like this.


[source]
....
(dbg (repeat 5 "x") "repeat 5 times"))
; => ("x" "x" "x" "x" "x")
....
  
.REPL output
....
dbg: (repeat 5 "x")   <repeat five times> =>
|   ("x" "x" "x" "x" "x")
....


### Number option

If you don't specify the number after the form, *debux* macros will print and return
default 100 items in each collection by default.

[source]
....
(dbg (range 200))
; => (0 1 2 ... 99)
....

.REPL output
[listing]
----
dbg: (range 200) =>
|   (0 1 2  ... 99)
----

So, if you want to print less or more than 100 items, specify the number explicitly.

....
(dbg (range 200) 200)
; => (0 1 2 ... 199)
....

.REPL output
[listing]
----
dbg: (range 200) =>
|   (0 1 2 ... 199)
----

The same rule applies in case of evaluating an *infinite lazy-seq*. If you omit the number
in evaluating an *infinite lazy-seq*, in the same manner it will print and return default
100 elements to prevent `OutOfMemoryError`.

[source]
....
(dbg (range))
; => (0 1 2 ... 99)
....
  
.REPL output
....
dbg: (range) =>
|   (0 1 2 ... 99)
....


### `:if` option

You can set `:if` expression like this.

[source]
....
(for [i (range 10)]
  (dbg i :if (even? i)))
; => (0 1 2 3 4 5 6 7 8 9)
....

.REPL output
....
dbg: i =>
|   0

dbg: i =>
|   2

dbg: i =>
|   4

dbg: i =>
|   6

dbg: i =>
|   8
....


### `:style` option (CSS Styling)

The following is the example of using `clog` and `clogn` macros in Google Chrome
browser.
 
[source]
.example.core.cljs
....
(ns example.core
  (:require [debux.cs.core :as d :refer-macros [clog clogn dbg dbgn break]]))

(clog (repeat 5 "x") "5 times repeat")
(clogn (repeat 5 (repeat 5 "x")) "25 times repeat")
....

image::clog-1.png[title="clog and clogn example", width=600]


#### Predefined style keywords

You can style the form, using the following predefined keywords.

[cols="^,^", options="header", width="30"]
|===

| keyword | abbreviation
| :style  | :s
| :error  | :e
| :warn   | :w
| :info   | :i
| :debug  | :d

|===

....
(clog (+ 10 20) :style :error "error style")
(clog (+ 10 20) :style :warn "warn style")
(clog (+ 10 20) :style :info "info style")
(clog (+ 10 20) :style :debug "debug style")
(clog (+ 10 20) "debug style is default")
....
  
Or in brief

....  
(clog (+ 10 20) :s :e "error style")
(clog (+ 10 20) :s :w "warn style")
(clog (+ 10 20) :s :i "info style")
(clog (+ 10 20) :s :d "debug style")
(clog (+ 10 20) "debug style is default")
....

image::clog-2.png[title="Predefined style example", width=550]


#### User-defined style

You can redefine the predefined styles or define your own new style like this.


[source]
....
(d/merge-style {:warn "background: #9400D3; color: white"
                :love "background: #FF1493; color: white"})

(clog (+ 10 20) :style :warn "warn style changed")
(clog (+ 10 20) :style :love "love style")

;; You can style the form directly in string format in any way you want.
(clog (+ 10 20) :style "color:orange; background:blue; font-size: 14pt")
....

image::clog-3.png[title="User-defined style example", width=550]


### `:once` option

If you add `:once` (or `:o` in brief) option after the form, the same evaluated value will
not be printed. This is a very useful feature, when you are debugging a game programming,
where successive multiple frames usually have the same evaluated value.


[source]
....
(def a (atom 10))

;; This will be printed.
(clog @a :once)

;; This will not be printed,
;; because the evaluated value is the same as before.
(clog @a :once)


(reset! a 20)

;; This will be printed,
;; because the evaluated value is not the same as before.
(clog @a :once)

;; This will not be printed,
;; because the evaluated value is the same as before.
(clog @a :once)
....

image::clog-4.png[title=":once option example", width=550]

NOTE: `(:once mode)` string is appended after the form header to remind you of `:once`
  mode.

   
### `:js` option

If `:js` option is added after the form, the JavaScript object will be printed as well, so
you can inspect the internal structures of ClojureScript data types.

....
(clog {:a 10 :b 20} :js)
....

image::clog-5.png[title=":js option example", width=550]


## `break`

### `break` options

You can use `break` to set the breakpoint in the sourc code like this. You can add string
option for message, or `:if` option for conditional break.

[source]
....
(break)
(break "hello world")
(break :if (< 10 20) "10 is less than 20")
(break :if (> 10 20) "this will not be printed")
....

You can see the message in DevTool's console window.

image:break-1.png[title="break examples", width=550]


### Callstack, locals, etc

After setting the breakpoint, you can inspect the callstack, locals, etc. in the browser's
DevTool window.

[source]
....
(defn my-fun2
  [a {:keys [b c d] :or {d 10 b 20 c 30}} [e f g & h]]
  (break)
  (clog [a b c d e f g h]))

(my-fun2 (take 5 (range)) {:c 50 :d 100} ["a" "b" "c" "d" "e"]) 
....

image:break-2.png[]

You can see the message in DevTool's console window.

image:break-3.png[width=550]
  

### `:if` option example
  
When using `break`, you can use `:if expression` like this.

[source]
....
(defn my-fun3 []
  (let [a 10
        b 20]
    (dotimes [i 1000]
      (break :if (= i 999)))))

(my-fun3)
....

image:break-4.png[]



## `break`

You can use `break` to set the breakpoint in the sourc code like this. After that you can
inspect the callstack, locals, etc. in the browser's DevTool window.

[source]
....
(defn my-fun2
  [a {:keys [b c d] :or {d 10 b 20 c 30}} [e f g & h]]
  (break)
  (clog [a b c d e f g h]))

(my-fun2 (take 5 (range)) {:c 50 :d 100} ["a" "b" "c" "d" "e"]) 
....

image:break.png[]
  
  
When using `break`, you can use `:if expression` like this.

[source]
....
(defn my-fun3 []
  (let [a 10
        b 20]
    (dotimes [i 1000]
      (break :if (= i 999)))))

(my-fun3)
....

image:break-if.png[]
  

## Usage in ClojureScript on Browser REPL

You can use both `dbg/dbgn` and `clog/clogn` macros on the browser REPL. The following is
an example about runing the link:https://github.com/bhauman/lein-figwheel[figwheel].

[source]
.project.clj
....
(defproject example "0.1.0-SNAPSHOT"
  :dependencies [[org.clojure/clojure "1.8.0"]
                 [org.clojure/clojurescript "1.9.562"]
                 [philoskim/debux "0.3.1"]]
  :plugins [[lein-cljsbuild "1.1.6"]
            [lein-figwheel  "0.5.10"]]
  :source-paths ["src/clj"]
  :clean-targets ^{:protect false}
                 ["resources/public/js/app.js"
                  "resources/public/js/app.js.map"]
  :cljsbuild {:builds [{:id "dev"
                        :source-paths ["src/cljs"]
                        :figwheel true
                        :compiler {:main example.core
                                   :asset-path "js/out"
                                   :output-to "resources/public/js/app.js"
                                   :output-dir "resources/public/js/out"
                                   :source-map true
                                   :optimizations :none} }]})
....


And then run figwheel like this on terminal window.


[listing]
----
$ lein figwheel
Figwheel: Cutting some fruit, just a sec ...
Figwheel: Validating the configuration found in project.clj
Figwheel: Configuration Valid :)
Figwheel: Starting server at http://0.0.0.0:3449
Figwheel: Watching build - dev
Compiling "resources/public/js/app.js" from ["src/cljs"]...
Successfully compiled "resources/public/js/app.js" in 2.14 seconds.
Launching ClojureScript REPL for build: dev
Figwheel Controls:
          (stop-autobuild)                ;; stops Figwheel autobuilder
          (start-autobuild [id ...])      ;; starts autobuilder focused on optional ids
          (switch-to-build id ...)        ;; switches autobuilder to different build
          (reset-autobuild)               ;; stops, cleans, and starts autobuilder
          (reload-config)                 ;; reloads build config and resets autobuild
          (build-once [id ...])           ;; builds source one time
          (clean-builds [id ..])          ;; deletes compiled cljs target files
          (print-config [id ...])         ;; prints out build configurations
          (fig-status)                    ;; displays current state of system
          (figwheel.client/set-autoload false)    ;; will turn autoloading off
          (figwheel.client/set-repl-pprint false) ;; will turn pretty printing off
  Switch REPL build focus:
          :cljs/quit                      ;; allows you to switch REPL to another build
    Docs: (doc function-name-here)
    Exit: Control+C or :cljs/quit
 Results: Stored in vars *1, *2, *3, *e holds last exception object
Prompt will show when Figwheel connects to your application
----

After that, connect to `http://localhost:3449` on your borwser.

[listing]
----
To quit, type: :cljs/quit
cljs.user=> (require '[debux.cs.core :refer-macros [clog clogn dbg dbgn break]])        
nil
  
cljs.user=> (dbg (+ 1 2))

dbg: (+ 1 2) =>
|   3
3
  
cljs.user=> 
----

Now you can do anything in this browser REPL as in the Clojure REPL. When you evaluate
`dbg` macro in your ClojureScript source code, the result will go to the REPL window and
when you evaluate `clog` macro in your ClojureScript source code, the result will go to
your browser's console window.


## License
Copyright Â© 2015--2017 Young Tae Kim

Distributed under the Eclipse Public License either version 1.0 or any later version.
